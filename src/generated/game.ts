// @generated by protobuf-ts 2.11.1 with parameter long_type_string
// @generated from protobuf file "game.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * 게임 내 기본 엔티티 (유닛, 몬스터)의 위치를 정의합니다.
 *
 * @generated from protobuf message Position
 */
export interface Position {
    /**
     * @generated from protobuf field: int32 x = 1
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 2
     */
    y: number;
}
/**
 * 동물이자 플레이어의 유닛을 정의합니다.
 *
 * @generated from protobuf message Animal
 */
export interface Animal {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string animalId = 2
     */
    animalId: string; // 예를 들어 "cat", "dog"
    /**
     * @generated from protobuf field: int32 health = 3
     */
    health: number;
    /**
     * @generated from protobuf field: Position position = 4
     */
    position?: Position;
}
/**
 * 몬스터를 정의합니다.
 *
 * @generated from protobuf message Monster
 */
export interface Monster {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string monsterId = 2
     */
    monsterId: string; // 예를 들어 "orc", "goblin"
    /**
     * @generated from protobuf field: int32 health = 3
     */
    health: number;
    /**
     * @generated from protobuf field: Position position = 4
     */
    position?: Position;
}
/**
 * 데미지 이벤트를 정의합니다.
 *
 * @generated from protobuf message DamageEvent
 */
export interface DamageEvent {
    /**
     * @generated from protobuf field: string targetId = 1
     */
    targetId: string;
    /**
     * @generated from protobuf field: int32 damage = 2
     */
    damage: number;
    /**
     * @generated from protobuf field: bool isMonster = 3
     */
    isMonster: boolean; // 몬스터인지 여부 (true: 몬스터, false: 유닛)
}
/**
 * 클라이언트에게 전송되는 전체 게임 상태 업데이트 메시지입니다.
 *
 * @generated from protobuf message GameStateUpdate
 */
export interface GameStateUpdate {
    /**
     * @generated from protobuf field: map<string, Animal> animals = 1
     */
    animals: {
        [key: string]: Animal;
    };
    /**
     * @generated from protobuf field: map<string, Monster> monsters = 2
     */
    monsters: {
        [key: string]: Monster;
    };
    /**
     * @generated from protobuf field: int32 gold = 3
     */
    gold: number;
    /**
     * @generated from protobuf field: int32 baseHealth = 4
     */
    baseHealth: number;
    /**
     * @generated from protobuf field: int32 score = 5
     */
    score: number;
    /**
     * @generated from protobuf field: int32 stage = 6
     */
    stage: number;
    /**
     * @generated from protobuf field: repeated DamageEvent damageEvents = 7
     */
    damageEvents: DamageEvent[];
}
/**
 * 게임 시작 요청 메시지
 *
 * @generated from protobuf message GameStartRequest
 */
export interface GameStartRequest {
    /**
     * @generated from protobuf field: string userId = 1
     */
    userId: string;
}
/**
 * 유닛 소환 요청 메시지
 *
 * @generated from protobuf message SummonUnitRequest
 */
export interface SummonUnitRequest {
    /**
     * @generated from protobuf field: string animalId = 1
     */
    animalId: string;
    /**
     * @generated from protobuf field: Position position = 2
     */
    position?: Position;
}
/**
 * 게임 종료/스테이지 클리어 메시지
 *
 * @generated from protobuf message GameEndEvent
 */
export interface GameEndEvent {
    /**
     * @generated from protobuf field: int32 score = 1
     */
    score: number;
    /**
     * @generated from protobuf field: bool isGameOver = 2
     */
    isGameOver: boolean;
    /**
     * @generated from protobuf field: bool isStageCompleted = 3
     */
    isStageCompleted: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class Position$Type extends MessageType<Position> {
    constructor() {
        super("Position", [
            { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Position>): Position {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<Position>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Position): Position {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 x */ 1:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 2:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Position, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).int32(message.x);
        /* int32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Position
 */
export const Position = new Position$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Animal$Type extends MessageType<Animal> {
    constructor() {
        super("Animal", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "animalId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "health", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "position", kind: "message", T: () => Position }
        ]);
    }
    create(value?: PartialMessage<Animal>): Animal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.animalId = "";
        message.health = 0;
        if (value !== undefined)
            reflectionMergePartial<Animal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Animal): Animal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string animalId */ 2:
                    message.animalId = reader.string();
                    break;
                case /* int32 health */ 3:
                    message.health = reader.int32();
                    break;
                case /* Position position */ 4:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Animal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string animalId = 2; */
        if (message.animalId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.animalId);
        /* int32 health = 3; */
        if (message.health !== 0)
            writer.tag(3, WireType.Varint).int32(message.health);
        /* Position position = 4; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Animal
 */
export const Animal = new Animal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Monster$Type extends MessageType<Monster> {
    constructor() {
        super("Monster", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "monsterId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "health", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "position", kind: "message", T: () => Position }
        ]);
    }
    create(value?: PartialMessage<Monster>): Monster {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.monsterId = "";
        message.health = 0;
        if (value !== undefined)
            reflectionMergePartial<Monster>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Monster): Monster {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string monsterId */ 2:
                    message.monsterId = reader.string();
                    break;
                case /* int32 health */ 3:
                    message.health = reader.int32();
                    break;
                case /* Position position */ 4:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Monster, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string monsterId = 2; */
        if (message.monsterId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.monsterId);
        /* int32 health = 3; */
        if (message.health !== 0)
            writer.tag(3, WireType.Varint).int32(message.health);
        /* Position position = 4; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Monster
 */
export const Monster = new Monster$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DamageEvent$Type extends MessageType<DamageEvent> {
    constructor() {
        super("DamageEvent", [
            { no: 1, name: "targetId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "damage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "isMonster", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DamageEvent>): DamageEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.targetId = "";
        message.damage = 0;
        message.isMonster = false;
        if (value !== undefined)
            reflectionMergePartial<DamageEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DamageEvent): DamageEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string targetId */ 1:
                    message.targetId = reader.string();
                    break;
                case /* int32 damage */ 2:
                    message.damage = reader.int32();
                    break;
                case /* bool isMonster */ 3:
                    message.isMonster = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DamageEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string targetId = 1; */
        if (message.targetId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.targetId);
        /* int32 damage = 2; */
        if (message.damage !== 0)
            writer.tag(2, WireType.Varint).int32(message.damage);
        /* bool isMonster = 3; */
        if (message.isMonster !== false)
            writer.tag(3, WireType.Varint).bool(message.isMonster);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DamageEvent
 */
export const DamageEvent = new DamageEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameStateUpdate$Type extends MessageType<GameStateUpdate> {
    constructor() {
        super("GameStateUpdate", [
            { no: 1, name: "animals", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Animal } },
            { no: 2, name: "monsters", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Monster } },
            { no: 3, name: "gold", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "baseHealth", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "stage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "damageEvents", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DamageEvent }
        ]);
    }
    create(value?: PartialMessage<GameStateUpdate>): GameStateUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.animals = {};
        message.monsters = {};
        message.gold = 0;
        message.baseHealth = 0;
        message.score = 0;
        message.stage = 0;
        message.damageEvents = [];
        if (value !== undefined)
            reflectionMergePartial<GameStateUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameStateUpdate): GameStateUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, Animal> animals */ 1:
                    this.binaryReadMap1(message.animals, reader, options);
                    break;
                case /* map<string, Monster> monsters */ 2:
                    this.binaryReadMap2(message.monsters, reader, options);
                    break;
                case /* int32 gold */ 3:
                    message.gold = reader.int32();
                    break;
                case /* int32 baseHealth */ 4:
                    message.baseHealth = reader.int32();
                    break;
                case /* int32 score */ 5:
                    message.score = reader.int32();
                    break;
                case /* int32 stage */ 6:
                    message.stage = reader.int32();
                    break;
                case /* repeated DamageEvent damageEvents */ 7:
                    message.damageEvents.push(DamageEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GameStateUpdate["animals"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateUpdate["animals"] | undefined, val: GameStateUpdate["animals"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Animal.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for GameStateUpdate.animals");
            }
        }
        map[key ?? ""] = val ?? Animal.create();
    }
    private binaryReadMap2(map: GameStateUpdate["monsters"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GameStateUpdate["monsters"] | undefined, val: GameStateUpdate["monsters"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Monster.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for GameStateUpdate.monsters");
            }
        }
        map[key ?? ""] = val ?? Monster.create();
    }
    internalBinaryWrite(message: GameStateUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, Animal> animals = 1; */
        for (let k of globalThis.Object.keys(message.animals)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Animal.internalBinaryWrite(message.animals[k], writer, options);
            writer.join().join();
        }
        /* map<string, Monster> monsters = 2; */
        for (let k of globalThis.Object.keys(message.monsters)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Monster.internalBinaryWrite(message.monsters[k], writer, options);
            writer.join().join();
        }
        /* int32 gold = 3; */
        if (message.gold !== 0)
            writer.tag(3, WireType.Varint).int32(message.gold);
        /* int32 baseHealth = 4; */
        if (message.baseHealth !== 0)
            writer.tag(4, WireType.Varint).int32(message.baseHealth);
        /* int32 score = 5; */
        if (message.score !== 0)
            writer.tag(5, WireType.Varint).int32(message.score);
        /* int32 stage = 6; */
        if (message.stage !== 0)
            writer.tag(6, WireType.Varint).int32(message.stage);
        /* repeated DamageEvent damageEvents = 7; */
        for (let i = 0; i < message.damageEvents.length; i++)
            DamageEvent.internalBinaryWrite(message.damageEvents[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GameStateUpdate
 */
export const GameStateUpdate = new GameStateUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameStartRequest$Type extends MessageType<GameStartRequest> {
    constructor() {
        super("GameStartRequest", [
            { no: 1, name: "userId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GameStartRequest>): GameStartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        if (value !== undefined)
            reflectionMergePartial<GameStartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameStartRequest): GameStartRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string userId */ 1:
                    message.userId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameStartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string userId = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GameStartRequest
 */
export const GameStartRequest = new GameStartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummonUnitRequest$Type extends MessageType<SummonUnitRequest> {
    constructor() {
        super("SummonUnitRequest", [
            { no: 1, name: "animalId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "position", kind: "message", T: () => Position }
        ]);
    }
    create(value?: PartialMessage<SummonUnitRequest>): SummonUnitRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.animalId = "";
        if (value !== undefined)
            reflectionMergePartial<SummonUnitRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SummonUnitRequest): SummonUnitRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string animalId */ 1:
                    message.animalId = reader.string();
                    break;
                case /* Position position */ 2:
                    message.position = Position.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SummonUnitRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string animalId = 1; */
        if (message.animalId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.animalId);
        /* Position position = 2; */
        if (message.position)
            Position.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SummonUnitRequest
 */
export const SummonUnitRequest = new SummonUnitRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameEndEvent$Type extends MessageType<GameEndEvent> {
    constructor() {
        super("GameEndEvent", [
            { no: 1, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "isGameOver", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "isStageCompleted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GameEndEvent>): GameEndEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.score = 0;
        message.isGameOver = false;
        message.isStageCompleted = false;
        if (value !== undefined)
            reflectionMergePartial<GameEndEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameEndEvent): GameEndEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 score */ 1:
                    message.score = reader.int32();
                    break;
                case /* bool isGameOver */ 2:
                    message.isGameOver = reader.bool();
                    break;
                case /* bool isStageCompleted */ 3:
                    message.isStageCompleted = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameEndEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 score = 1; */
        if (message.score !== 0)
            writer.tag(1, WireType.Varint).int32(message.score);
        /* bool isGameOver = 2; */
        if (message.isGameOver !== false)
            writer.tag(2, WireType.Varint).bool(message.isGameOver);
        /* bool isStageCompleted = 3; */
        if (message.isStageCompleted !== false)
            writer.tag(3, WireType.Varint).bool(message.isStageCompleted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GameEndEvent
 */
export const GameEndEvent = new GameEndEvent$Type();
